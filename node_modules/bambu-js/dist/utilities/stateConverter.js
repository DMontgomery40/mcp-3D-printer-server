"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = convertState;
const PrintStage_1 = require("../types/PrintStage");
/**
 * Convert raw state to printer state.
 * @param rawState Raw state returned by the printer.
 * @returns Printer state.
 */
function convertState(rawState) {
    var _a, _b, _c, _d, _e;
    return {
        timestamp: rawState.timestamp,
        nozzle: {
            temperature: rawState.nozzle_temper,
            targetTemperature: rawState.nozzle_target_temper,
            diameter: parseFloat(rawState.nozzle_diameter),
            type: rawState.nozzle_type,
        },
        bed: {
            temperature: rawState.bed_temper,
            targetTemperature: rawState.bed_target_temper,
        },
        camera: {
            record: ((_a = rawState.ipcam) === null || _a === void 0 ? void 0 : _a.ipcam_record) === "enable",
            timelapse: ((_b = rawState.ipcam) === null || _b === void 0 ? void 0 : _b.timelapse) === "enable",
            resolution: (_d = (_c = rawState.ipcam) === null || _c === void 0 ? void 0 : _c.resolution) !== null && _d !== void 0 ? _d : "unknown",
        },
        chamber: {
            temperature: rawState.chamber_temper,
        },
        controller: {
            printName: rawState.gcode_file,
            printStage: (_e = PrintStage_1.printStageValues[rawState.mc_print_stage]) !== null && _e !== void 0 ? _e : PrintStage_1.PrintStage.UNKNOWN,
            printSubStage: rawState.mc_print_sub_stage,
            printLineNumber: parseInt(rawState.mc_print_line_number),
            printPercent: rawState.mc_percent,
            printTimeRemaining: rawState.mc_remaining_time,
        },
        lights: rawState.lights_report,
        errors: rawState.hms,
    };
}
//# sourceMappingURL=stateConverter.js.map